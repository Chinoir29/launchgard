import * as fs from 'fs';
import * as path from 'path';
import { ScanReport, Violation } from './types/index.js';

export class Reporter {
  generateMarkdown(report: ScanReport): string {
    let output = '# LaunchGuard Scan Report\n\n';
    output += `**Timestamp:** ${report.timestamp}\n`;
    output += `**Mode:** ${report.mode}\n`;
    output += `**Files Scanned:** ${report.filesScanned}\n\n`;

    output += '## Summary\n\n';
    output += `- **Status:** ${report.summary.passed ? '✅ PASS' : '❌ FAIL'}\n`;
    output += `- **Errors:** ${report.summary.errors}\n`;
    output += `- **Warnings:** ${report.summary.warnings}\n\n`;

    if (report.violations.length > 0) {
      output += '## Violations\n\n';

      // Group by file
      const byFile = this.groupByFile(report.violations);
      for (const [file, violations] of Object.entries(byFile)) {
        output += `### ${file}\n\n`;
        for (const violation of violations) {
          const icon = violation.severity === 'error' ? '❌' : '⚠️';
          output += `${icon} **${violation.ruleId}** (Line ${violation.line}:${violation.column})\n`;
          output += `   ${violation.message}\n`;
          if (violation.context) {
            output += `   \`\`\`\n   ${violation.context}\n   \`\`\`\n`;
          }
          output += '\n';
        }
      }
    }

    if (report.claimLedger.length > 0) {
      output += '## Claim Ledger\n\n';
      output += 'Claims found in scanned files:\n\n';
      output += '| File | Line | Tag | Needs Source | Claim |\n';
      output += '|------|------|-----|--------------|-------|\n';

      for (const claim of report.claimLedger) {
        const needsSource = claim.needsSource ? '⚠️ Yes' : 'No';
        const claimText = claim.claim
          .replace(/\\/g, '\\\\')
          .replace(/\|/g, '\\|')
          .substring(0, 80);
        output += `| ${claim.file} | ${claim.line} | ${claim.tag} | ${needsSource} | ${claimText} |\n`;
      }
      output += '\n';
    }

    output += '---\n';
    output += '*Generated by LaunchGuard - Deterministic quality gate for docs*\n';

    return output;
  }

  generateConsoleOutput(report: ScanReport): string {
    let output = '\n';
    output += '═══════════════════════════════════════════════════════════\n';
    output += '  LaunchGuard Scan Results\n';
    output += '═══════════════════════════════════════════════════════════\n\n';

    output += `Mode:          ${report.mode.toUpperCase()}\n`;
    output += `Files Scanned: ${report.filesScanned}\n`;
    output += `Status:        ${report.summary.passed ? '✅ PASS' : '❌ FAIL'}\n`;
    output += `Errors:        ${report.summary.errors}\n`;
    output += `Warnings:      ${report.summary.warnings}\n`;

    if (report.violations.length > 0) {
      output += '\n───────────────────────────────────────────────────────────\n';
      output += ' Violations\n';
      output += '───────────────────────────────────────────────────────────\n\n';

      for (const violation of report.violations) {
        const icon = violation.severity === 'error' ? '❌' : '⚠️';
        output += `${icon} ${violation.file}:${violation.line}:${violation.column}\n`;
        output += `   [${violation.ruleId}] ${violation.message}\n`;
        if (violation.context) {
          output += `   ${violation.context}\n`;
        }
        output += '\n';
      }
    }

    if (report.claimLedger.length > 0 && report.claimLedger.length <= 10) {
      output += '\n───────────────────────────────────────────────────────────\n';
      output += ' Claim Ledger (sample)\n';
      output += '───────────────────────────────────────────────────────────\n\n';

      for (const claim of report.claimLedger.slice(0, 10)) {
        const needsSource = claim.needsSource ? ' [NEEDS SOURCE]' : '';
        output += `[${claim.tag}]${needsSource} ${claim.file}:${claim.line}\n`;
        output += `  ${claim.claim.substring(0, 80)}\n\n`;
      }

      if (report.claimLedger.length > 10) {
        output += `... and ${report.claimLedger.length - 10} more claims\n\n`;
      }
    }

    output += '═══════════════════════════════════════════════════════════\n';

    return output;
  }

  async writeReports(report: ScanReport, outputDir: string): Promise<void> {
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write JSON report
    const jsonPath = path.join(outputDir, 'report.json');
    fs.writeFileSync(jsonPath, JSON.stringify(report, null, 2), 'utf-8');

    // Write Markdown report
    const mdPath = path.join(outputDir, 'report.md');
    fs.writeFileSync(mdPath, this.generateMarkdown(report), 'utf-8');
  }

  private groupByFile(violations: Violation[]): Record<string, Violation[]> {
    const grouped: Record<string, Violation[]> = {};
    for (const violation of violations) {
      if (!grouped[violation.file]) {
        grouped[violation.file] = [];
      }
      grouped[violation.file].push(violation);
    }
    return grouped;
  }
}
